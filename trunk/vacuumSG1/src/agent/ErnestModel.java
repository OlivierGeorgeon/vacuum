package agent;


import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.geom.Ellipse2D;
import java.util.ArrayList;
import java.util.List;

import javax.vecmath.Matrix3f;
import javax.vecmath.Vector3f;

import memory.Colliculus;
import memory110.Point;
import memory110.Segment;

import ernest.*;
import utils.Pair;
import spas.IPlace;
import spas.ISegment;
import tracing.*;

/**************************************
 * A Model for Ernest 
 * This class gathers methods that, we believe, will survive generations of Ernests.
 * @author ogeorgeon
 **************************************/
public class ErnestModel extends Model 
{

	private final static Color AGENT_COLOR = new Color(100,100,100);
	
	public static int ACTION_FORWARD = 0;
	public static int ACTION_LEFT = 1;
	public static int ACTION_RIGHT = 2;
	
	public static int AGENT_STOP = 0;
	public static int AGENT_RUN = 1;
	public static int AGENT_STEP = 2;
	
	public int cognitiveMode = AGENT_STOP;

	/** The angular field of each eye. */
	private double m_eyeAngle ;
	protected void setEyeAngle(double angle) {m_eyeAngle = angle;}
	protected double getEyeAngle() {return m_eyeAngle;}
	
	/** Ernest's sensorymotor system. */
	protected IErnest m_ernest;
	protected ISensorymotorSystem m_sensorymotorSystem;
	protected ITracer m_tracer;

	/**
	 * Value of the diagonal projection in 2D:
	 * 1 for a square diagonal,
	 * 1/sqrt(2) for a circle diagonal.
	 */
	public final static float INV_SQRT_2 = (float) (1/Math.sqrt(2));
	final private float DIAG2D_PROJ = INV_SQRT_2;

	// Local directions
	final public Vector3f DIRECTION_AHEAD = new Vector3f(1, 0, 0);
	final public Vector3f DIRECTION_BEHIND = new Vector3f(-1, 0, 0);
	final public Vector3f DIRECTION_LEFT = new Vector3f(0, 1, 0);
	final public Vector3f DIRECTION_RIGHT = new Vector3f(0, -1, 0);
	final public Vector3f DIRECTION_AHEAD_LEFT = new Vector3f(DIAG2D_PROJ, DIAG2D_PROJ, 0);
	final public Vector3f DIRECTION_AHEAD_RIGHT = new Vector3f(DIAG2D_PROJ, -DIAG2D_PROJ, 0);
	final public Vector3f DIRECTION_BEHIND_LEFT = new Vector3f(-DIAG2D_PROJ, DIAG2D_PROJ, 0);
	final public Vector3f DIRECTION_BEHIND_RIGHT = new Vector3f(-DIAG2D_PROJ, -DIAG2D_PROJ, 0);	
	final public static float SOMATO_RADIUS = 1.1f;
	final public static float TACTILE_RADIUS = .8f;
	
	// Absolute directions in Cartesian coordinates (0,0) bottom left.
	final protected Vector3f DIRECTION_NORTH = new Vector3f(0, 1, 0);
	final protected Vector3f DIRECTION_NORTHEAST = new Vector3f(1, 1, 0);
	final protected Vector3f DIRECTION_EAST = new Vector3f(1, 0, 0);
	final protected Vector3f DIRECTION_SOUTHEAST = new Vector3f(1, -1, 0);
	final protected Vector3f DIRECTION_SOUTH = new Vector3f(0, -1, 0);
	final protected Vector3f DIRECTION_SOUTHWEST = new Vector3f(-1, -1, 0);
	final protected Vector3f DIRECTION_WEST = new Vector3f(-1, 0, 0);
	final protected Vector3f DIRECTION_NORTHWEST = new Vector3f(-1, 1, 0);
	
	public InternalView m_eye;
	public int lastAction;
	
	public Vector3f mPreviousPosition = new Vector3f(mPosition);
	public Vector3f mPreviousOrientation = new Vector3f(mOrientation);
	
	public Vector3f mSpeedT;    // translation and rotation speed in absolute reference
	public Vector3f mSpeedR;    // translation and rotation speed in absolute reference
	
	public Vector3f mEgoSpeedT;    // translation and rotation speed in absolute reference
	
	public ErnestModel(int i) 
	{
		super(i);
		m_eye=new InternalView();
		mSpeedT=new Vector3f(0f,0f,0f);
		mSpeedR=new Vector3f(0f,0f,0f);
		
		mEgoSpeedT=new Vector3f(0f,0f,0f);
	}
	
	/**
	 * Initialize the Ernest agent.
	 */
	public void initErnest()
	{
		
	}
	
	public void closeErnest()
	{
		//m_tracer.close();
		mOrientation.z=(float) (Math.PI/2);
		m_ernest = null;
	}
	
	/**
	 * Update the agent when the environment is refreshed.
	 * (not necessarily a cognitive step for the agent).
	 */
	public void update()
	{
//		int[] intention = stepErnest(status);
//		status = enactSchema(intention);
	}
	
	/**
	 * Run Ernest one step
	 */
	public int[] stepErnest(boolean status)
	{

		// Sense the environment
		int [][] matrix = new int [2][1];
		
		//m_sensorymotorSystem.senseMatrix(matrix);
		
		//String intention = m_ernest.step(matrix);
		String intention = Character.toString((char)m_ernest.step(matrix)[0]);

		//return intention;
		return m_ernest.step(matrix);
	}
	
//	public boolean enactSchema(int[] schema)
//	{
//		return true;
//	}
	
	/**
	 * Trace an event generated by the user, typically: a mouse click to change a square on the grid.
	 * @param type The event's type.
	 * @param x The x coordinate on the grid.
	 * @param y The y coordinate on the grid.
	 */
	public void traceUserEvent(String type, int x, int y)
	{
		//Object element = m_tracer.newEvent("user", type, m_counter);
		//m_tracer.addSubelement(element, "x", x + "");
		//m_tracer.addSubelement(element, "y", y + "");
	}
	
	/**
	 * Generates a retina image from Ernest's view point.
	 * (Uses Ernest's orientationRad value, trigonometric, counterclockwise, radius).
	 * @return The array of colors projected onto the retina.
	 */ 
	protected Pair<Integer, Color>[] getRetina(double orientationRad) {
		@SuppressWarnings("unchecked")
		Pair<Integer, Color>[] retina = new Pair[Ernest.RESOLUTION_RETINA];
		double angle = orientationRad - Math.PI/2;
		double angleStep = Math.PI / Ernest.RESOLUTION_RETINA;
		for (int i = 0; i < Ernest.RESOLUTION_RETINA; i++) {
			retina[i] = scanArc((float)angle, (float)angleStep);
			angle += angleStep;
		}
		return retina;
	}
	
	/**
	 * Scan an arc from Ernest's viewpoint, starting from the initial angle position and going through the angular span.
	 * Stop scanning at the first singularity found.
	 * @param t The initial angular position (trigonometric/counterclockwise - radian)
	 * @param a The arc's angular span (trigonometric/counterclockwise)
	 * @param 20 The arc's diameter (the agent's visual range)
	 * @return the color detected. 
	 */
	protected Pair<Integer, Color> scanArc(float t, float a) {
		Pair<Integer, Color> eyeFixation = null;
		float step = a/2;
		for (float angle = t; angle <= t + a + .001; angle += step) {
			float x0 = (float) (mPosition.x + 20 * Math.cos(angle));
			float y0 = (float) (mPosition.y + 20 * Math.sin(angle)); // Y axis is downwards.
			//float y0 = (float) (m_y + 20 * Math.sin(angle)); // Y axis is upwards.
			eyeFixation = rayTrace(mPosition.x,mPosition.y, x0, y0);
			// We stop when we find a singularity.
			if (eyeFixation.mRight != WALL_COLOR)
				break;
		}
		if (eyeFixation==null)
			return Pair.create(Ernest.INFINITE, WALL_COLOR);
		return eyeFixation;
	}
	
	/**
	 * Scan the squares that are on a ray from a viewpoint to a target square
	 *  http://playtechs.blogspot.com/2007/03/raytracing-on-grid.html 
	 * @return Distance to the dirty square if any, Ernest.INFINITE if no dirt. 
	 */
	protected Pair<Integer, Color> rayTrace(float x0, float y0, float x1, float y1) {
		float dx = Math.abs(x1 - x0);
		float dy = Math.abs(y1 - y0);
	    int i = (int) Math.round(x0);
	    int j = (int) Math.round(y0);
	    int n = 1;
	    int i_inc, j_inc;
	    float error;
	    //int k = Math.round(mPosition.getZ());
	    float cornerTresh = .05f * dx * dy;

	    if (dx == 0) {
	        i_inc = 0;
	        error = Float.POSITIVE_INFINITY;
	    } else if (x1 > x0) {
	        i_inc = 1;
	        n += (int) Math.round(x1) - i;
	        error = (float) (((Math.round(x0) + .5f) - x0) * dy);
	    } else {
	        i_inc = -1;
	        n += i - (int) Math.round(x1);
	        error = (float) ((x0 - (Math.round(x0) - .5f)) * dy);
	    }
	    if (dy == 0) {
	        j_inc = 0;
	        error -= Float.POSITIVE_INFINITY;
	    } else if (y1 > y0) {
	        j_inc = 1;
	        n += (int) Math.round(y1) - j;
	        error -= ((Math.round(y0) + .5f) - y0) * dx;
	    } else {
	        j_inc = -1;
	        n += j - (int) Math.round(y1);
	        error -= (y0 - (Math.round(y0) - .5f)) * dx;
	    }
	    for (; n > 0; --n) 
	    {
	        // move on along the ray
	        if (error > cornerTresh) {
	            j += j_inc;
	            error -= dx;
	        } else if (error < -cornerTresh) {
	            i += i_inc;
	            error += dy;
	        } else {
	        	i += i_inc;
	    		j += j_inc;
	    		error += dy - dx;
	    		--n;
	        }

	        // Don't go outside the grid
	    	if ((i < 0) || (j < 0) || (i >= m_w) || (j >= m_h)) 
	    		return Pair.create(Ernest.INFINITE, WALL_COLOR);
	    	
	    	// Examine the block on the ray. Return wall or uninhibited dirty squares.
	    	Color bgc = m_env.m_blocks[i][j].seeBlock();
	    	if (m_env.isWall(i,j) || m_env.isFood(i,j) || m_env.isAlga(i,j))
	    	{
				int dist = (int) Math.sqrt(((i-x0)*(i-x0) + (j-y0)*(j-y0)) * Ernest.INT_FACTOR * Ernest.INT_FACTOR);
				return Pair.create(dist, bgc);
    		}
	    	//if (m_env.isAgent(i, j, mName))
	    	ErnestModel entity = m_env.getEntity(new Vector3f(i,j,0), mName);
	    	if (entity != null)
	    	{
				int dist = (int) Math.sqrt(((i-x0)*(i-x0) + (j-y0)*(j-y0)) * Ernest.INT_FACTOR * Ernest.INT_FACTOR);
				return Pair.create(dist, entity.getColor());//AGENT_COLOR);
	    	}

	    }
		return Pair.create(Ernest.INFINITE, WALL_COLOR);
	}

	/**
	 * Compute the tactile stimuli 
	 * @return The matrix of tactile stimuli. 
	 */
	protected int[] somatoMap() {
		int[] somatoMap = new int[9];
		somatoMap[0] = soma(DIRECTION_BEHIND_RIGHT);
		somatoMap[1] = soma(DIRECTION_RIGHT);
		somatoMap[2] = soma(DIRECTION_AHEAD_RIGHT);
		somatoMap[3] = soma(DIRECTION_AHEAD);
		somatoMap[4] = soma(DIRECTION_AHEAD_LEFT);
		somatoMap[5] = soma(DIRECTION_LEFT);
		somatoMap[6] = soma(DIRECTION_BEHIND_LEFT);
		somatoMap[7] = soma(DIRECTION_BEHIND);
		somatoMap[8] = soma(new Vector3f());

		return somatoMap;
	}
	/**
	 * Tactile stimuli. 
	 * @param direction The direction of the touch in Ernest's referential.
	 * @return The tactile stimulus in this direction. 
	 */
	protected int soma(Vector3f direction) {
		int soma = Ernest.STIMULATION_TOUCH_EMPTY;
		Vector3f localPoint = new Vector3f(direction);
		localPoint.scale(SOMATO_RADIUS);
		Vector3f point = localToParentRef(localPoint);
		if (affordTouchSoft(point))
			soma = Ernest.STIMULATION_TOUCH_SOFT;
		if (affordEat(point))
			soma = Ernest.STIMULATION_TOUCH_FISH;
		if (!affordWalk(point)) 
			soma = Ernest.STIMULATION_TOUCH_WALL;
		return soma;
	}
	/**
	 * @param localVec A position relative to Ernest.
	 * @return The absolute position relative to the board ((rotZ(mOrientation.z) * localVec) + mPosition). 
	 */
	public Vector3f localToParentRef(Vector3f localVec) {
		
		Matrix3f rot = new Matrix3f();
		rot.rotZ(mOrientation.z);
		
		Vector3f parentVec = new Vector3f();
		rot.transform(localVec, parentVec); // (rot * localVec) is placed into parentVec
		//parentVec.add(new Vector3f(m_x, m_y, 0));
		parentVec.add(mPosition); // now parentVec = (rotZ(mOrientation.z) * localVec) + mPosition.
		return parentVec;
	}	
	
	/**
	 * Ernest's 
	 */
	public void ernestDynamic()
	{
		mTranslation.scale(.9f);
		mPosition.add(mTranslation);
		//m_x = mPosition.x;
		//m_y = m_h - mPosition.y;
		
		mRotation.scale(.9f);
		mOrientation.add(mRotation);
	}
	
	public Vector3f cellCenter(Vector3f position)
	{
		Vector3f cellCenter = new Vector3f(Math.round(position.x), Math.round(position.y), Math.round(position.z));
		return cellCenter;
	}

	public void keepDistance(Vector3f position, Vector3f point, float distance)
	{
		if (point != null)
		{
			Vector3f toPoint = new Vector3f(point);
			toPoint.sub(position);
			if (toPoint.length() < distance)
			{
				//position.add(toPoint);
				position.set(point);
				toPoint.normalize();
				toPoint.scale(- distance);
				position.add(toPoint);
			}
		}
	}
	
//	public List<IPlace> getPlaceList(){
//		return m_ernest.getPlaceList();
//	}
	
	
	
	
	//******************************************
	////////////////////////////////////////////
	//******************************************
	
	public void updateColliculus(double[] rv2, Color[] colorMap2, double[] rt2, int[] tactileMap2, int lastAction2, float speed){
		
	}
	
	protected EyeFixation[] rendu(){
		return rendu(false,0);
	}
	
	
	protected EyeFixation[] rendu(boolean sensor,float speed){
		double[] rv    = new double[360];          // visual distance vector (absolute orientation)
		double[] rv2   = new double[360];          // visual distance vector (agent orientation)
		double[] rt    = new double[360];          // tactile distance vector (absolute orientation)
		double[] rt2   = new double[360];          // tactile distance vector (agent orientation)
		
		double[] zVMap = new double[360];          // visual  Z-Map
		double[] zTMap = new double[360];          // tactile Z-Map
		
		Color[] colorMap =new Color[360];          // color vector (absolute orientation)
		Color[] colorMap2=new Color[360];          // color vector (agent orientation)
		int[] tactileMap =new int[360];            // tactile property vector (absolute orientation)
		int[] tactileMap2=new int[360];            // tactile property vector (agent orientation)
		
		int[] cornerV = new int[360];              // visual corner vector
		int[] cornerV2= new int[360];
		int[] cornerT = new int[360];              // tactile corner vector
		int[] cornerT2= new int[360];
		
		Color[][] visualImage=new Color[360][200];
		
		ArrayList<Point> cornersPoints=new ArrayList<Point>();
		ArrayList<ISegment> segments=new ArrayList<ISegment>();
		
		EyeFixation[] retina= new EyeFixation[Ernest.RESOLUTION_RETINA];
		
		double d=0;
		double d1,d2,d3,d4;
		double a1,a2,a3,a4;
		
		double imin,iplus,jmin,jplus;
		double imin2,jmin2;
		
		int Im_x=Math.round(mPosition.x);
		int Im_y=Math.round(mPosition.y);
		
		
		// reset vectors
		for (int i=0;i<360;i++){
			zVMap[i]=1000;
			zTMap[i]=1000;
			rv[i]=200;
			rt[i]=200;
			colorMap[i]=new Color(0,0,0);
			tactileMap[i]=0;
		}
		
		int sight=20;                                              // maximum distance
		
		
		// the area around the agent is divided into five parts
		// 4 4 4 4 5 1 1 1 1
		// 4 4 4 4 5 1 1 1 1
		// 4 4 4 4 5 1 1 1 1
		// 3 3 3 3 A 1 1 1 1
		// 3 3 3 3 2 2 2 2 2
		// 3 3 3 3 2 2 2 2 2
		// 3 3 3 3 2 2 2 2 2

		
		for (int i=0;i<sight;i++){
			for (int j=0;j<sight;j++){
				
				int Im_xpi=Im_x+i;
				int Im_ypj=Im_y+j;
				
				int Im_xmi=Im_x-i;
				int Im_ymj=Im_y-j;
				
				// (1) cells on the top right side
				if ( (i>0)&& (Im_xpi<m_w) && (Im_ypj<m_h) ){
					if (!m_env.isEmpty(Im_xpi,Im_ypj) ){
						// determine color and tactile property of a block
						Color bgc = m_env.seeBlock(Im_xpi,Im_ypj);
						int tactile=m_env.touchBlock(Im_xpi,Im_ypj);
						
						// determine the position of the three visible points of the block in polar reference
						imin =(double)i-0.5 - (mPosition.x-Im_x);
						imin2=imin*imin;
						iplus=(double)i+0.5 - (mPosition.x-Im_x);
						jmin =(double)j-0.5 - (mPosition.y-Im_y);
						jmin2=jmin*jmin;
						jplus=(double)j+0.5 - (mPosition.y-Im_y);
						
						d1=  imin2 + jmin2;
						d1=Math.sqrt(d1);
						d2=  imin2 + (jplus*jplus);
						d2=Math.sqrt(d2);
						d3=  (iplus*iplus) + jmin2;
						d3=Math.sqrt(d3);
						
						a1=  Math.toDegrees( Math.acos( jmin/d1));
						a2=  Math.toDegrees( Math.acos( jplus/d2));
						a3=  Math.toDegrees( Math.acos( jmin/d3));
						
						
				    	int ai1=(int)a1;
				    	int ai2=(int)a2;
				    	int ai3=(int)a3;
						
				    	// fill the output vectors with the first visible segment
						for (int k=ai2;k<=ai1;k++){
							
							//d=10* imin/Math.cos((double)(90-k)*Math.PI/180);
							
							d= d2*10 +   (d1-d2)*10*(k-ai2)/(ai1-ai2);
							
							
							// visual vector if the block is visible
							if (m_env.isVisible(Im_xpi,Im_ypj)){
								if (zVMap[k]>d){
									rv[k]=d;                        // fill Z-Map
									zVMap[k]= d;
									colorMap[k]=bgc;

								}
							}
							// tactile vector
							if (zTMap[k]>d){
								rt[k]=d;
								zTMap[k]= d;
								tactileMap[k]=tactile;
								if      (k==ai2) cornerT[k]=1;
								else if (k==ai1) cornerT[k]=2;
								else             cornerT[k]=0;
							}
						}	
						// fill the output vectors with the second visible segment (if visible)
						if (imin>0){
						for (int k=ai1;k<=ai3;k++){
							
							//d=10* jmin/Math.cos((k)*Math.PI/180);
							
							d= d1*10 +   (d3-d1)*10*(k-ai1)/(ai3-ai1);
							// visual vector if the block is visible
							if (m_env.isVisible(Im_xpi,Im_ypj)){
								if (zVMap[k]>d){
									rv[k]=d;
									zVMap[k]= d;
									colorMap[k]=bgc;

								}
							}
							// tactile vector
							if (zTMap[k]>d){
								rt[k]=d;
								zTMap[k]= d;
								tactileMap[k]=tactile;
								if      (k==ai1) cornerT[k]=1;
								else if (k==ai3) cornerT[k]=2;
								else             cornerT[k]=0;
							}
						}
						}
						
						
						// corners
						// 1
						if ( (!m_env.isVisible(Im_xpi-1,Im_ypj) && !m_env.isVisible(Im_xpi,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xpi-1,Im_ypj) &&  m_env.isVisible(Im_xpi,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xpi-1,Im_ypj) && !m_env.seeBlock(Im_xpi-1, Im_ypj).equals(m_env.seeBlock(Im_xpi, Im_ypj)))
						   ||( m_env.isVisible(Im_xpi,Im_ypj-1) && !m_env.seeBlock(Im_xpi, Im_ypj-1).equals(m_env.seeBlock(Im_xpi, Im_ypj))) ){
									
								cornersPoints.add(new Point( (float)imin , (float)jmin, ai1,0) );
						}
						
						// 2
						if (Im_ypj+1<m_h && (!m_env.isVisible(Im_xpi-1,Im_ypj)))
						if ( (!m_env.isVisible(Im_xpi-1,Im_ypj) && !m_env.isVisible(Im_xpi,Im_ypj+1))
						   ||( m_env.isVisible(Im_xpi-1,Im_ypj+1) )
						   ||( m_env.isVisible(Im_xpi,Im_ypj+1) && !m_env.seeBlock(Im_xpi, Im_ypj+1).equals(m_env.seeBlock(Im_xpi, Im_ypj))) ){
							
							cornersPoints.add(new Point( (float)imin , (float)jplus, ai2,0) );
						}
						
						// 3
						if (Im_xpi+1<m_h && !m_env.isVisible(Im_xpi,Im_ypj-1))
						if ( (!m_env.isVisible(Im_xpi+1,Im_ypj) && !m_env.isVisible(Im_xpi+1,Im_ypj))
						   ||( m_env.isVisible(Im_xpi+1,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xpi+1,Im_ypj) && !m_env.seeBlock(Im_xpi+1, Im_ypj).equals(m_env.seeBlock(Im_xpi, Im_ypj))) ){
							
							cornersPoints.add(new Point( (float)iplus , (float)jmin, ai3,0) );
						}
					}
				}

				// (2) cells on the bottom right side
				if ( (j>0) && (Im_xpi<m_w) && (Im_ymj>=0) ){
					if (!m_env.isEmpty(Im_xpi,Im_ymj) ){
						Color bgc = m_env.seeBlock(Im_xpi,Im_ymj);
						int tactile=m_env.touchBlock(Im_xpi,Im_ymj);
						
						
						
						imin =(double)i-0.5 - (mPosition.x-Im_x);
						imin2=imin*imin;
						iplus=(double)i+0.5 - (mPosition.x-Im_x);
						jmin =(double)j-0.5 + (mPosition.y-Im_y);
						jmin2=jmin*jmin;
						jplus=(double)j+0.5 + (mPosition.y-Im_y);
						
						d1=  imin2 + jmin2;
						d1=Math.sqrt(d1);
						d2=  (iplus*iplus) + jmin2;
						d2=Math.sqrt(d2);
						d3=  imin2 + (jplus*jplus);
						d3=Math.sqrt(d3);
						
						a1=  Math.toDegrees( Math.acos( jmin/d1));
						a2=  Math.toDegrees( Math.acos( jmin/d2));
						a3=  Math.toDegrees( Math.acos( jplus/d3));
						
				    	int ai1,ai2,ai3;
				    	
				    	if (i-0.5>=0){
				    		ai1=180-(int)a1;
				    		ai3=180-(int)a3;
				    	}
				    	else{
				    		ai1=180+(int)a1;
				    		ai3=180+(int)a3;
				    	}
				    	ai2=180-(int)a2;
						
						for (int k=ai2;k<=ai1;k++){
							d= ( d2*10 +   (d1-d2)*10*(k-ai2)/(ai1-ai2));
							if (m_env.isVisible(Im_xpi,Im_ymj)){
								if (zVMap[k]>d){
									rv[k]=d;
									zVMap[k]= d;
									colorMap[k]=bgc;
									
								}
							}
							if (zTMap[k]>d){
								rt[k]=d;
								zTMap[k]= d;
								tactileMap[k]=tactile;
							
								if      (k==ai2) cornerT[k]=1;
								else if (k==ai1) cornerT[k]=2;
								else             cornerT[k]=0;
							}
						}		
						for (int k=ai1;k<=ai3;k++){
							d= ( d1*10 +   (d3-d1)*10*(k-ai1)/(ai3-ai1));
							if (m_env.isVisible(Im_xpi,Im_ymj)){
								if (zVMap[k]>d){
									rv[k]=d;
									zVMap[k]= d;
									colorMap[k]=bgc;

								}
							}
							if (zTMap[k]>d){
								rt[k]=d;
								zTMap[k]= d;
								tactileMap[k]=tactile;
							
								if      (k==ai1) cornerT[k]=1;
								else if (k==ai3) cornerT[k]=2;
								else             cornerT[k]=0;
							}
						}
						
						// corners
						// 1
						if ( (!m_env.isVisible(Im_xpi,Im_ymj+1) && !m_env.isVisible(Im_xpi-1,Im_ymj) )
						   ||( m_env.isVisible(Im_xpi,Im_ymj+1) &&  m_env.isVisible(Im_xpi-1,Im_ymj) )
						   ||( m_env.isVisible(Im_xpi,Im_ymj+1) && !m_env.seeBlock(Im_xpi, Im_ymj+1).equals(m_env.seeBlock(Im_xpi, Im_ymj)))
						   ||( m_env.isVisible(Im_xpi-1,Im_ymj) && !m_env.seeBlock(Im_xpi-1, Im_ymj).equals(m_env.seeBlock(Im_xpi, Im_ymj))) ){
									
								cornersPoints.add(new Point( (float)imin , -(float)jmin, ai1,0) );
						}
						
						
						// 2
						if (Im_xpi+1<m_w && !m_env.isVisible(Im_xpi,Im_ymj+1))
						if ( (!m_env.isVisible(Im_xpi+1,Im_ymj+1) && !m_env.isVisible(Im_xpi+1,Im_ymj))
						   ||( m_env.isVisible(Im_xpi+1,Im_ymj+1) )
						   ||( m_env.isVisible(Im_xpi+1,Im_ymj) && !m_env.seeBlock(Im_xpi+1, Im_ymj).equals(m_env.seeBlock(Im_xpi, Im_ymj))) ){
							
							cornersPoints.add(new Point( (float)iplus , -(float)jmin, ai2,0) );
						}
						
						// 3
						if (Im_xpi+1<m_h && !m_env.isVisible(Im_xpi-1,Im_ymj))
						if ( (!m_env.isVisible(Im_xpi-1,Im_ymj-1) && !m_env.isVisible(Im_xpi,Im_ymj-1))
						   ||( m_env.isVisible(Im_xpi-1,Im_ymj-1) )
						   ||( m_env.isVisible(Im_xpi,Im_ymj-1) && !m_env.seeBlock(Im_xpi, Im_ymj-1).equals(m_env.seeBlock(Im_xpi, Im_ymj))) ){
							
							cornersPoints.add(new Point( (float)imin , -(float)jplus, ai3,0) );
						}
					}
				}
				
				
				// (3) cells on the bottom left side
				if ( (i>0) && (Im_xmi>=0) && (Im_ymj>=0) ){
					if (!m_env.isEmpty(Im_xmi,Im_ymj) ){
						Color bgc = m_env.seeBlock(Im_xmi,Im_ymj);
						int tactile=m_env.touchBlock(Im_xmi,Im_ymj);
						
						imin =(double)i-0.5 + (mPosition.x-Im_x);
						imin2=imin*imin;
						iplus=(double)i+0.5 + (mPosition.x-Im_x);
						jmin =(double)j-0.5 + (mPosition.y-Im_y);
						jmin2=jmin*jmin;
						jplus=(double)j+0.5 + (mPosition.y-Im_y);
						
						d1=  imin2 + jmin2;
						d1=Math.sqrt(d1);
						d2=  imin2 + (jplus*jplus);
						d2=Math.sqrt(d2);
						d3=  (iplus*iplus) + jmin2;
						d3=Math.sqrt(d3);
						
						a1=  Math.toDegrees( Math.acos( jmin/d1));
						a2=  Math.toDegrees( Math.acos( jplus/d2));
						a3=  Math.toDegrees( Math.acos( jmin/d3));
						
				    	int ai1=180+(int)a1;
				    	int ai2=180+(int)a2;
				    	int ai3=180+(int)a3;
						
						for (int k=ai2;k<=ai1;k++){
							d=   d2*10 +   (d1-d2)*10*(k-ai2)/(ai1-ai2);
							if (m_env.isVisible(Im_xmi,Im_ymj)){
								if (zVMap[k]>d){
									rv[k]=d;
									zVMap[k]=d;
									colorMap[k]=bgc;
								}
							}
							if (zTMap[k]>d){
								rt[k]=d;
								zTMap[k]=d;
								tactileMap[k]=tactile;
								if      (k==ai2) cornerT[k]=1;
								else if (k==ai1) cornerT[k]=2;
								else             cornerT[k]=0;
							}
						}		
						for (int k=ai1;k<=ai3;k++){
							d=  d1*10 +   (d3-d1)*10*(k-ai1)/(ai3-ai1);
							if (m_env.isVisible(Im_xmi,Im_ymj)){
								if (zVMap[k]>d){
									rv[k]=d;
									zVMap[k]=d;
									colorMap[k]=bgc;

								}
							}
							if (zTMap[k]>d){
								rt[k]=d;
								zTMap[k]=d;
								tactileMap[k]=tactile;
								if      (k==ai1) cornerT[k]=1;
								else if (k==ai3) cornerT[k]=2;
								else             cornerT[k]=0;
							}
						}
						
						// corners
						// 1
						if ( (!m_env.isVisible(Im_xmi,Im_ymj+1) && !m_env.isVisible(Im_xmi+1,Im_ymj) )
						   ||( m_env.isVisible(Im_xmi,Im_ymj+1) &&  m_env.isVisible(Im_xmi+1,Im_ymj) )
						   ||( m_env.isVisible(Im_xmi,Im_ymj+1) && !m_env.seeBlock(Im_xmi, Im_ymj+1).equals(m_env.seeBlock(Im_xmi, Im_ymj)))
						   ||( m_env.isVisible(Im_xmi+1,Im_ymj) && !m_env.seeBlock(Im_xmi+1, Im_ymj).equals(m_env.seeBlock(Im_xmi, Im_ymj))) ){
									
								cornersPoints.add(new Point( -(float)imin , -(float)jmin, ai1,0) );
						}
						
						// 2
						if (Im_ymj-1>=0 && !m_env.isVisible(Im_xmi+1,Im_ymj))
						if ( (!m_env.isVisible(Im_xmi,Im_ymj-1) && !m_env.isVisible(Im_xmi+1,Im_ymj-1))
						   ||( m_env.isVisible(Im_xmi+1,Im_ymj-1) )
						   ||( m_env.isVisible(Im_xmi,Im_ymj-1) && !m_env.seeBlock(Im_xmi, Im_ymj-1).equals(m_env.seeBlock(Im_xmi, Im_ymj))) ){
							
							cornersPoints.add(new Point( -(float)imin , -(float)jplus, ai2,0) );
						}
						
						
						// 3
						if (Im_xmi-1>=0 && !m_env.isVisible(Im_xmi,Im_ymj+1))
						if ( (!m_env.isVisible(Im_xmi,Im_ymj+1) && !m_env.isVisible(Im_xmi-1,Im_ymj))
						   ||( m_env.isVisible(Im_xmi-1,Im_ymj+1) )
						   ||( m_env.isVisible(Im_xmi-1,Im_ymj) && !m_env.seeBlock(Im_xmi-1, Im_ymj).equals(m_env.seeBlock(Im_xmi, Im_ymj))) ){
							
							cornersPoints.add(new Point( -(float)iplus , -(float)jmin, ai3,0) );
						}
						
					}
				}
				
				// (5) cells exactly on the top
				// In this case, there is only two visible points and one visible segment
				if ( (j>0) && (i==0) && (Im_ypj<m_h) ){
					if (!m_env.isEmpty(Im_xmi,Im_ypj) ){
						Color bgc = m_env.seeBlock(Im_xmi,Im_ypj);
						int tactile=m_env.touchBlock(Im_xmi,Im_ypj);
						
						imin =(double)i-0.5 + (mPosition.x-Im_x);
						imin2=imin*imin;
						iplus=(double)i+0.5 + (mPosition.x-Im_x);
						jmin =(double)j-0.5 - (mPosition.y-Im_y);
						jmin2=jmin*jmin;
						
						d1=  imin2 + jmin2;
						d1=Math.sqrt(d1);
						d2=  (iplus*iplus) + jmin2;
						d2=Math.sqrt(d2);
						
						a1=  Math.toDegrees( Math.acos( jmin/d1));
						a2=  Math.toDegrees( Math.acos( jmin/d2));

						
						int ai1,ai2;
						ai1=(int)a1;
				    	ai2=360-(int)a2;
				    	if (ai2==360) ai2=359;
				    	
				    	int count=0;
				    	for (int k=ai2;k<360;k++){
				    		d= d2*10 +   (d1-d2)*10*(k-ai2)/((ai1-ai2+360)%360);
				    		if (m_env.isVisible(Im_xmi,Im_ypj)){
				    			if (zVMap[k]>d){
				    				rv[k]=d;
				    				zVMap[k]= d;
				    				colorMap[k]=bgc;
				    			}
				    		}
				    		if (zTMap[k]>d){
			    				rt[k]=d;
			    				zTMap[k]= d;
			    				tactileMap[k]=tactile;
			    				if      (k==ai2) cornerT[k]=1;
			    				else             cornerT[k]=0;
			    			}
				    		count++;
				    	}
				    	for (int k=0;k<=ai1;k++){
				    		d= d2*10 +   (d1-d2)*10*(k+count)/((ai1-ai2+360)%360);
				    		if (m_env.isVisible(Im_xmi,Im_ypj)){
				    			if (zVMap[k]>d){
				    				rv[k]=d;
				    				zVMap[k]= d;
				    				colorMap[k]=bgc;
				    			}
				    		}
				    		if (zTMap[k]>d){
			    				rt[k]=d;
			    				zTMap[k]= d;
			    				tactileMap[k]=tactile;
			    				if (k==ai1) cornerT[k]=2;
			    				else        cornerT[k]=0;	
			    			}
				    	}
				    	
				    	
				    	// corners
				    	// 1
						if (!m_env.isVisible(Im_xmi,Im_ypj-1))
						if ( (!m_env.isVisible(Im_xmi+1,Im_ypj))
						   ||( m_env.isVisible(Im_xmi+1,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xmi+1,Im_ypj) && !m_env.seeBlock(Im_xmi+1, Im_ypj).equals(m_env.seeBlock(Im_xmi, Im_ypj))) ){
							
							cornersPoints.add(new Point( -(float)imin , (float)jmin, ai1,0) );
						}
						
						
						// 2
						if (!m_env.isVisible(Im_xmi,Im_ypj-1))
						if ( (!m_env.isVisible(Im_xmi-1,Im_ypj))
						   ||( m_env.isVisible(Im_xmi-1,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xmi-1,Im_ypj) && !m_env.seeBlock(Im_xmi-1, Im_ypj).equals(m_env.seeBlock(Im_xmi, Im_ypj))) ){
							
							cornersPoints.add(new Point( -(float)iplus , (float)jmin, ai2,0) );
						}

					}
				}
				
				// (4) cells on the top left side
				if ( (j>0) && (i>0) && (Im_xmi>=0) && (Im_ypj<m_h) ){
					if (!m_env.isEmpty(Im_xmi,Im_ypj) ){
						Color bgc = m_env.seeBlock(Im_xmi,Im_ypj);
						int tactile=m_env.touchBlock(Im_xmi,Im_ypj);
						
						imin =(double)i-0.5 + (mPosition.x-Im_x);
						imin2=imin*imin;
						iplus=(double)i+0.5 + (mPosition.x-Im_x);
						jmin =(double)j-0.5 - (mPosition.y-Im_y);
						jmin2=jmin*jmin;
						jplus=(double)j+0.5 - (mPosition.y-Im_y);
						
						d1=  imin2 + jmin2;
						d1=Math.sqrt(d1);
						d2=  (iplus*iplus) + jmin2;
						d2=Math.sqrt(d2);
						d3=  imin2 + (jplus*jplus);
						d3=Math.sqrt(d3);
						
						a1=  Math.toDegrees( Math.acos( jmin/d1));
						a2=  Math.toDegrees( Math.acos( jmin/d2));
						a3=  Math.toDegrees( Math.acos( jplus/d3));
						
						int ai1,ai2,ai3;
						ai1=360-(int)a1;
						ai3=360-(int)a3;
						if (ai1==360) ai1=359;
						if (ai3==360) ai3=359;
				    	ai2=360-(int)a2;
						
				    	for (int k=ai2;k<=ai1;k++){
				    		d= d2*10 +   (d1-d2)*10*(k-ai2)/(ai1-ai2);
				    		if (m_env.isVisible(Im_xmi,Im_ypj)){
				    			if (zVMap[k]>d){
				    				rv[k]=d;
				    				zVMap[k]= d;
				    				colorMap[k]=bgc;
				    			}
				    		}
				    		if (zTMap[k]>d){
			    				rt[k]=d;
			    				zTMap[k]= d;
			    				tactileMap[k]=tactile;
			    				if      (k==ai2) cornerT[k]=1;
			    				else if (k==ai1) cornerT[k]=2;
			    				else             cornerT[k]=0;
			    			}
				    	}		
				    	for (int k=ai1;k<=ai3;k++){
				    		d= d1*10 +   (d3-d1)*10*(k-ai1)/(ai3-ai1);
				    		if (m_env.isVisible(Im_xmi,Im_ypj)){
				    			if (zVMap[k]>d-0.01){
				    				rv[k]=d;
				    				zVMap[k]=d;
				    				colorMap[k]=bgc;
				    			}
				    		}
				    		if (zTMap[k]>d-0.01){
			    				rt[k]=d;
			    				zTMap[k]=d;
			    				tactileMap[k]=tactile;
			    				if      (k==ai1) cornerT[k]=1;
			    				else if (k==ai3) cornerT[k]=2;
			    				else             cornerT[k]=0;
			    			}
				    	}
						
				    	// corners
						// 1
						if ( (!m_env.isVisible(Im_xmi+1,Im_ypj) && !m_env.isVisible(Im_xmi,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xmi+1,Im_ypj) &&  m_env.isVisible(Im_xmi,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xmi+1,Im_ypj) && !m_env.seeBlock(Im_xmi+1, Im_ypj).equals(m_env.seeBlock(Im_xmi, Im_ypj)))
						   ||( m_env.isVisible(Im_xmi,Im_ypj-1) && !m_env.seeBlock(Im_xmi, Im_ypj-1).equals(m_env.seeBlock(Im_xmi, Im_ypj))) ){
									
								cornersPoints.add(new Point( -(float)imin , (float)jmin, ai1,0) );
						}
						
						
						// 2
						if (Im_xmi-1>=0 && !m_env.isVisible(Im_xmi,Im_ypj-1))
						if ( (!m_env.isVisible(Im_xmi-1,Im_ypj) && !m_env.isVisible(Im_xmi,Im_ypj-1))
						   ||( m_env.isVisible(Im_xmi-1,Im_ypj-1) )
						   ||( m_env.isVisible(Im_xmi-1,Im_ypj) && !m_env.seeBlock(Im_xmi-1, Im_ypj).equals(m_env.seeBlock(Im_xmi, Im_ypj))) ){
							
							cornersPoints.add(new Point( -(float)iplus , (float)jmin, ai2,0) );
						}
						
						// 3
						if (Im_ypj+1<m_h && !m_env.isVisible(Im_xmi+1,Im_ypj))
						if ( (!m_env.isVisible(Im_xmi,Im_ypj+1) && !m_env.isVisible(Im_xmi+1,Im_ypj))
						   ||( m_env.isVisible(Im_xmi+1,Im_ypj+1) )
						   ||( m_env.isVisible(Im_xmi,Im_ypj+1) && !m_env.seeBlock(Im_xmi, Im_ypj+1).equals(m_env.seeBlock(Im_xmi, Im_ypj))) ){
							
							cornersPoints.add(new Point( -(float)imin , (float)jplus, ai3,0) );
						}
						
					}
				}	
			}
		}
		
		// agents detection
		for (int a=0;a<m_env.m_modelList.size();a++){
			//Color bgc = m_env.AGENT;
			int tactile=m_env.CUDDLE;
			if (m_env.m_modelList.get(a).ident!=ident){
				d= (mPosition.x-m_env.m_modelList.get(a).mPosition.x)*(mPosition.x-m_env.m_modelList.get(a).mPosition.x)
				  +(mPosition.y-m_env.m_modelList.get(a).mPosition.y)*(mPosition.y-m_env.m_modelList.get(a).mPosition.y);
				d=Math.sqrt(d);
				
				int ai1=0;
				int ai2=0;
				int ai3=0;
				int ai4=0;
				if (mPosition.x-m_env.m_modelList.get(a).mPosition.x<=0){
					a1=Math.toDegrees( Math.acos( (mPosition.y-m_env.m_modelList.get(a).mPosition.y)/d));
					ai1=180-(int)a1;
				}
				else{
					a1=Math.toDegrees( Math.acos( (mPosition.y-m_env.m_modelList.get(a).mPosition.y)/d));
					ai1=(int)a1+180;
				}
				
				a2=Math.atan(0.4/d);
				a2=Math.toDegrees(a2);
				
				ai2= (int)a2;
				
				ai3=ai1-ai2+360;
				ai4=ai1+ai2+360;
				
				int ai5=ai4-ai3;
				
				for (int k=ai3;k<=ai4;k++){
					if (zVMap[k%360]>d*10){
						rv[k%360]=d*10 /*- 2*Math.sin(Math.PI*(k-ai3)/(ai4-ai3))*/;
						zVMap[k%360]= d*10 /*- 2*Math.sin(Math.PI*(k-ai3)/(ai4-ai3))*/;
						colorMap[k%360]=m_env.m_modelList.get(a).getColor(); //bgc;
					}
					
					if (zTMap[k%360]>d*10){
						rt[k%360]=d*10 /*- 2*Math.sin(Math.PI*(k-ai3)/(ai4-ai3))*/;
						zTMap[k%360]= d*10 /*- 2*Math.sin(Math.PI*(k-ai3)/(ai4-ai3))*/;
						tactileMap[k%360]=m_env.CUDDLE;
					}
				}
				
				// corners
		    	// 1
				ai3=ai3%360;
				float px=(float) (d*Math.cos(((-ai3+90)%360)*Math.PI/180));
				float py=(float) (d*Math.sin(((-ai3+90)%360)*Math.PI/180));
				cornersPoints.add(new Point(px,py,ai3,-1));
				cornersPoints.get(cornersPoints.size()-1).addSpeed(m_env.m_modelList.get(a).mSpeedT);
				
				// 2
				ai4=ai4%360;
				px=(float) (d*Math.cos(((-ai4+90)%360)*Math.PI/180));
				py=(float) (d*Math.sin(((-ai4+90)%360)*Math.PI/180));
				cornersPoints.add(new Point(px,py,ai4,-1));
				cornersPoints.get(cornersPoints.size()-1).addSpeed(m_env.m_modelList.get(a).mSpeedT);
				
			}
		}
		
		
		
		
		
		// remove masked point of interest
		int index=0;
		while (index<cornersPoints.size()){
			
			if (  cornersPoints.get(index).distance*10<=rv[cornersPoints.get(index).angle]+5
				||cornersPoints.get(index).distance*10<=rv[((cornersPoints.get(index).angle)-1+360)%360]+5
				||cornersPoints.get(index).distance*10<=rv[((cornersPoints.get(index).angle)+1+360)%360]+5){
				
				index++;
			}
			else{
				cornersPoints.remove(index);
			}
		}
		
		
		// remove double
		index=0;
		boolean test=false;
		while (index<cornersPoints.size()){
			test=false;
			for (int i=index+1;i<cornersPoints.size();i++){
				if (  Math.abs(cornersPoints.get(index).position.x*10 - cornersPoints.get(i).position.x*10)<2
				   && Math.abs(cornersPoints.get(index).position.y*10 - cornersPoints.get(i).position.y*10)<2){
					test=true;
				}
			}
			if (test) cornersPoints.remove(index);
			else index++;
		}
		
		index=0;
		while (index<cornersPoints.size()){
			int index2=index+1;
			test=false;
			boolean test2=false;    // indicate if the point Index is removed or not
			while (index2<cornersPoints.size() && !test2){
				if (Math.abs(cornersPoints.get(index).angle-cornersPoints.get(index2).angle)<=1){
					if (cornersPoints.get(index).distance>cornersPoints.get(index2).distance){
						cornersPoints.remove(index);
						test2=true;
					}
					else{
						cornersPoints.remove(index2);
					}
				}
				index2++;
			}
			if (!test2) index++;
		}
		
		
		
		
		// fill the output vectors (agent orientation)
		int orientationDeg= (int)(mOrientation.z * 180 / Math.PI);
		for (int i=0;i<360;i++){
			int offset=(i-orientationDeg+630)%360;
			rv2[i]= rv[offset];
			colorMap2[i]=colorMap[offset];
			
			rt2[i]= rt[offset];
			tactileMap2[i]=tactileMap[offset];
			cornerT2[i]=cornerT[offset];
		}
		for (int i=0;i<cornersPoints.size();i++){
			cornersPoints.get(i).rotate(-mOrientation.z, orientationDeg+90);
			cornerV2[cornersPoints.get(i).angle]=1;
		}
		
		
		int j=0;
		double x,y;
		for (int i=0;i<360;i++){
			j=(int) rv2[(359-i+180)%360]*2;
			double angle =mOrientation.z + (double)i*Math.PI/180;
			boolean found=false;
			while (j>0 && !found){
				x= mPosition.x + ((double)j/20)*Math.cos(angle);
				y= mPosition.y + ((double)j/20)*Math.sin(angle);
				if (Math.round(x)>=0 && Math.round(y)>=0 && Math.round(x)<m_w && Math.round(y)<m_h){
					//visualImage[i][j]= m_env.seeBlock(Math.round(x),Math.round(y));
					if (m_env.seeBlock(Math.round(x),Math.round(y)).equals(Model.FIELD_COLOR)){
						found=true;
						rv2[(359-i+180)%360]=(double)j/2;
						rt2[(359-i+180)%360]=(double)j/2;
					}
				}
				else found=true;
				j--;
				
			}
		}
		
		
		// detection of appearing and disappearing points
		for (int i=0;i<360;i++){
			
			if (cornerV2[i]>0){
				int i_min= (i-1+360)%360;
				int i_plus= (i+1+360)%360;
				double i_minRad =(-i_min +180)*Math.PI/180;
				double i_plusRad=(-i_plus+180)*Math.PI/180;
				if (rv2[i]+5<rv2[i_min]){
					cornersPoints.add(new Point( (float)(rv2[i_min]*Math.cos(i_minRad))/10 ,
                            					 (float)(rv2[i_min]*Math.sin(i_minRad))/10 ,
                            					 i_min , 1 ) );
					
				}
				if (rv2[i]+5<rv2[i_plus]){
					cornersPoints.add(new Point( (float)(rv2[i_plus]*Math.cos(i_plusRad))/10 ,
                            					 (float)(rv2[i_plus]*Math.sin(i_plusRad))/10 ,
                            					 i_plus , 2 ) );
				}
			}
		}
		
		
		
		// sort points by angle
		Point temp;
		for (int i=1;i<cornersPoints.size();i++){
			int memory=cornersPoints.get(i).angle;
			temp=cornersPoints.get(i);
			int compt=i-1;
			boolean marqueur;
			
			do{
				marqueur=false;
				if (cornersPoints.get(compt).angle>memory){
					cornersPoints.set(compt+1,cornersPoints.get(compt));
					compt--;
					marqueur=true;
                }
				if (compt<0) marqueur=false;
            }
			while(marqueur);
			cornersPoints.set(compt+1,temp);
        }
		
		// set points color
		for (int i=0;i<cornersPoints.size();i++){
			
			if ( rv2[cornersPoints.get(i).angle]+10 > rv2[(cornersPoints.get(i).angle+1+360)%360]){
				cornersPoints.get(i).setColorsRight(colorMap2[(cornersPoints.get(i).angle+1+360)%360]);
			}
			else{
				cornersPoints.get(i).setColorsRight(Color.black);
			}
			
			if ( rv2[cornersPoints.get(i).angle]+10 > rv2[(cornersPoints.get(i).angle-1+360)%360]){
				cornersPoints.get(i).setColorsLeft(colorMap2[(cornersPoints.get(i).angle-1+360)%360]);
			}
			else{
				cornersPoints.get(i).setColorsLeft(Color.black);
			}
			
			
			/*
			int d_angle, angle1,angle2;
			double dist=0;
			// left side color
			angle1=cornersPoints.get(i).angle;
			
			if (i==0) angle2=cornersPoints.get(cornersPoints.size()-1).angle;
			else      angle2=cornersPoints.get(i-1).angle;
			
			if (angle1<angle2) angle2-=360;
			
			d_angle=angle1-angle2;
			
			dist=rv2[angle1]-(rv2[angle1]-rv2[(angle2+360)%360])/d_angle;
			
			System.out.println("+++++++++++++++ "+d_angle+" ; "+rv2[angle1]+" , "+rv2[(angle2+360)%360]+" ; "+dist+" ~= "+rv[(angle1-1+360)%360]);
			
			if (Math.abs(dist-rv[(angle1-1+360)%360])<5){
				cornersPoints.get(i).setColorsRight(colorMap2[(cornersPoints.get(i).angle-1+360)%360]);
			}
			else{
				cornersPoints.get(i).setColorsRight(Color.black);
			}
			
			
			// right side color
			angle1=cornersPoints.get(i).angle;
			
			if (i==cornersPoints.size()-1) angle2=cornersPoints.get(0).angle;
			else                           angle2=cornersPoints.get(i+1).angle;
			
			if (angle1>angle2) angle2+=360;
			
			d_angle=angle1-angle2;
			
			dist=rv2[angle1]-(rv2[angle1]-rv2[(angle2+360)%360])/d_angle;
			
			if (Math.abs(dist-rv[(angle1+1+360)%360])<2){
				cornersPoints.get(i).setColorsRight(colorMap2[(cornersPoints.get(i).angle+1+360)%360]);
			}
			else{
				cornersPoints.get(i).setColorsRight(Color.black);
			}*/
		}

		
		
		// determine if points are appearing or disappearing
		for (int i=0;i<cornersPoints.size();i++){
			if (cornersPoints.get(i).type==1 || cornersPoints.get(i).type==2){
				
				float angle=mEgoSpeedT.x*cornersPoints.get(i).position.y-mEgoSpeedT.y*cornersPoints.get(i).position.x;
				
				if (angle>0){
					if (cornersPoints.get(i).type==1) cornersPoints.get(i).type=3;
					else cornersPoints.get(i).type=4;
				}
				if (angle<0){
					if (cornersPoints.get(i).type==1) cornersPoints.get(i).type=4;
					else cornersPoints.get(i).type=3;
				}
				
			}
		}/**/
		
		
		// update point speed
		Matrix3f rot = new Matrix3f();
		rot.rotZ( -mOrientation.z);
		rot.transform(mSpeedT, mEgoSpeedT);
		for (int i=1;i<cornersPoints.size();i++){
			cornersPoints.get(i).addRotation(mSpeedR);
			cornersPoints.get(i).subSpeed(mEgoSpeedT);
		}
		
		
		// generate segments
		for (int i=1;i<cornersPoints.size();i++){
			if (  (cornersPoints.get(i-1).type<=0 && cornersPoints.get(i).type<=0)
				||	( (cornersPoints.get(i-1).type<=0 || cornersPoints.get(i).type<=0) 
					&& cornersPoints.get(i-1).angle+1!=cornersPoints.get(i).angle) ){
				
				if (!cornersPoints.get(i-1).rightColor.equals(Color.black) && !cornersPoints.get(i).leftColor.equals(Color.black)){
					if (cornersPoints.get(i-1).rightColor.equals(cornersPoints.get(i).leftColor)){
						segments.add(new Segment(cornersPoints.get(i-1),cornersPoints.get(i)));
					}
				}
			}
		}
		segments.add(new Segment(cornersPoints.get(cornersPoints.size()-1),cornersPoints.get(0)));
	
		
		/*
		for (int i=0;i<360;i++){
			cornersPoints.add(new Point( (float)(rv2[i]*Math.cos((-i+180)*Math.PI/180))/10 ,
					 (float)(rv2[i]*Math.sin((-i+180)*Math.PI/180))/10 ,
					 (i+1+360)%360 , 10 ) );
		}/**/
		
		// fill the retina vector
		for (int i=0;i<Ernest.RESOLUTION_RETINA;i++){
			int angle=(int)(i*180/Ernest.RESOLUTION_RETINA+180/Ernest.RESOLUTION_RETINA/2+90);
			retina[Ernest.RESOLUTION_RETINA-i-1]= new EyeFixation();
			retina[Ernest.RESOLUTION_RETINA-i-1].setColor(colorMap2[angle]);
			retina[Ernest.RESOLUTION_RETINA-i-1].setDistance((int) rv2[angle]);
		}
		

		
		// update colliculus
		if (sensor){
			updateColliculus(rv2, colorMap2, rt2, tactileMap2, lastAction, speed);
			//colliculus.update(rv2, colorMap2, rt2, tactileMap2, lastAction, speed);
			//colliculusFrame.saveImage();
			//m_env.saveImage();
		}
		
		// update display
		m_eye.updateRetine(rv2,colorMap2,cornerV2,rt2,tactileMap2,cornerT2,cornersPoints,segments);
		/**/
		return retina;
	}
	
    public Color getColor()
    {
    	return AGENT_COLOR;
    }
    
    public boolean affordEat()
    {
    	return false;
    }
	
    public boolean affordCuddle()
    {
    	return true;
    }
	
	public int getCounter()
	{
		return m_ernest.getCounter();
	}

}
